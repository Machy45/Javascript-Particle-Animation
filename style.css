/* Setting the margin of the page to 0*/
/* Setting the padding of the page to 0*/
/* Box-sizing/border-box takes into account both the margin and padding and will 
optimise them for the width and height of the page*/
*{
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
}

/* The overflow property removes any overflowing items or scrollbars*/
/* Set the background colour to black*/
body{
    overflow: hidden;
    background-color: rgb(16, 15, 15);
}

/* A div with position absolute ignores other elements on the page and it allows you to 
change the position of an element by using right,left,top and bottom to 
mvoe the property around*/
canvas{
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
}


.intro{
    height: 100vh;
    background-color: black;
    background-size: cover;
    background-position: center center;
    width: 100%;
    color: aliceblue;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fade-out-left 2s forwards ease-in;
    animation-delay: 1.5s;
    position: absolute;
    z-index: 10;
}

@keyframes fade-out-left{
from{
opacity: 1;
transform: translate3d(0, 0, 0);
}
to{
opacity: 0;
transform: translate3d(-100%, 0, 0);
}
}



.intro h1{
    text-transform: uppercase;
    font-weight: 800;
    letter-spacing: 0.2rem;
    animation: fade-in 2s forwards ease-in;
}

@keyframes fade-in{
from{
opacity: 0;
}
to{
opacity: 1;
}
}

.navigation-bar{
    background-color: black;
    width: 100%;
    height: 3.5rem;
    align-items: center;
    justify-content: center;
    display: flex;
    position: relative;
    opacity: 0.6;
}

.navigation-bar a{
    text-decoration: none;
    color: rgb(255, 255, 255);
    margin-left: 1rem;
    line-height: 3rem;
    letter-spacing: 0.2rem;
    font-weight: lighter;
    font-size: 0.7rem;
    cursor: pointer;
    text-transform: uppercase;
    z-index: 100;
    transition-duration: 700ms;

}


.navigation-bar a:hover{
    border-bottom: 1px solid whitesmoke;
    letter-spacing: 0.5rem;
    padding: 0.2rem;
    border-radius: 5px;
    z-index: 10;
}


.main{
    display: flex;
    align-items: left;
    justify-content: left;
    padding: 20px;
    flex-direction: column;
    margin-top: 2rem;
    width: 100%;
    position: relative;
    text-shadow: 100px 0px 10px solid whitesmoke;
}


.main a{
    color: rgb(16, 15, 15);
    margin-top: 1rem;
    display: flex;
    align-items: left;
    justify-content: left;
    font-size: 4.5rem;
    width: 60%;
    text-decoration: none;
    font-weight: lighter;
    text-transform: uppercase;
    transition-duration: 700ms;
    
}

.main a:hover{
    letter-spacing: 0.5rem;
    color: aliceblue;
    font-weight: 900;
    border-bottom: 1px solid whitesmoke;
    padding: 0.2rem;
    border-radius: 3px;
}

.little_message{
    display: flex;
    align-items: right;
    justify-content: right;
    position: absolute;
    font-weight: 800;
    color: aliceblue;
    
}


.little_message p{
    font-weight: 800;
    letter-spacing: 0.1rem;
    padding: 10px;
}



/*class my_particles {
  constructor(x, y) {
    // The constructor will expect 2 attribuates, x and y
    this.x = x; // made a new variable called this.x and made it equal to the original x
    this.y = y; // made a new variable called this.y and made it equal to the original y
    this.size = 3; // set the radius of each particle
    this.moveX = this.x; //this will allow the particles to move back to their orginal positions at this.x
    this.moveY = this.y; //this will allow the particles to move back to their orginal positions at this.y
    this.particle_density = math.random() * 20; // making each particle move at a different speed when dispered
  }
  draw(){
    ctx.fillStyle = "white";
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); // drawing a full circle
    ctx.closePath();
    ctx.fill();
  }
}

// takes the particle class we just created and recalls it many times
function recalling() {
    canvasParticles = [];
    canvasParticles.push(new my_particles(100, 50));
    canvasParticles.push(new my_particles(100, 50));
}

//recalling();
//console.log(my_particles)

// Making an animation loop

function animate_it(){
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clears the canvas
    for (let i = 0; i < canvasParticles.length; i++){ //cycles through the entire particles array and foe each particle it will call it draw function
        canvasParticles[i].draw();
    }
    requestAnimationFrame(animate_it); // this animation will call itself over and over again creating a recursion function
}

animate_it(); */